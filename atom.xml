<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://hefeijoe.github.io/</id>
    <title>HefeiJoe Blog</title>
    <updated>2020-05-28T03:03:43.305Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://hefeijoe.github.io/"/>
    <link rel="self" href="https://hefeijoe.github.io/atom.xml"/>
    <subtitle>水滴石穿</subtitle>
    <logo>https://hefeijoe.github.io/images/avatar.png</logo>
    <icon>https://hefeijoe.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, HefeiJoe Blog</rights>
    <entry>
        <title type="html"><![CDATA[Java中的堆(heap)和栈(stack)]]></title>
        <id>https://hefeijoe.github.io/post/stackandheap/</id>
        <link href="https://hefeijoe.github.io/post/stackandheap/">
        </link>
        <updated>2020-05-28T01:48:09.000Z</updated>
        <content type="html"><![CDATA[<h1 id="栈stack">栈(stack)🤠</h1>
<p>Java里面Stack有两种含义：</p>
<h2 id="数据结构">数据结构</h2>
<p>Stack,即java.util.Stack，是Vector的一个子类，它实现了一个标准的后进先出的栈。<br>
Stack的特点为LIFO，即后进先出（Last in, first out）。</p>
<pre><code>public class Stack01 {
    public static void main(String[] args) {
        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();
        stack.push(1);//把元素压栈
        stack.empty();//判断stack是否为空
        stack.peek();//取栈顶元素但不弹出
        stack.search(1);//返回对象在堆栈中的位置，以 1 为基数。沒有查到则返回-1。
        stack.pop();//把栈顶的元素“弹出”
    }
}
</code></pre>
<p>一般与之比较的是队列Queue，队列是两个口，先进先出。</p>
<h2 id="内存区域">内存区域😚</h2>
<p>系统一般在内存中划分出两种不同的内存空间，一种是Stack(栈),一种是heap(堆)。<br>
<img src="https://pic1.zhimg.com/80/v2-e83cdfa865e6fb71caf65d7803c081bc_720w.jpg" alt="stack" loading="lazy"></p>
<h3 id="栈的组成">栈的组成</h3>
<p>栈帧由三部分组成：<strong>局部变量区</strong>、<strong>操作数栈</strong>、<strong>帧数据区</strong>。局部变量区和操作数栈的大小要视对应的方法而定，他们是按字长计算的。但调用一个方法时，它从类型信息中得到此方法局部变量区和操作数栈大小，并据此分配栈内存，然后压入Java栈。</p>
<h4 id="局部变量区">局部变量区</h4>
<p><strong>局部变量区</strong>被组织为以一个字长为单位、从0开始计数的数组，类型为short、byte和char的值在存入数组前要被转换成int值，而long和double在数组中占据连续的两项，在访问局部变量中的long或double时，只需取出连续两项的第一项的索引值即可,如某个long值在局部变量区中占据的索引时3、4项，取值时，指令只需取索引为3的long值即可。</p>
<pre><code>public static int runClassMethod(int i,long l,float f,double d,Object o,byte b) { 
    return 0;   
}
public int runInstanceMethod(char c,double d,short s,boolean b) { 
    return 0;   
}
</code></pre>
<h4 id="操作数栈">操作数栈</h4>
<p>和局部变量区一样，操作数栈也被组织成一个以字长为单位的数组。但和前者不同的是，它不是通过索引来访问的，而是通过入栈和出栈来访问的。可把操作数栈理解为存储计算时，临时数据的存储区域。<br>
操作数栈其实就是个临时数据存储区域，它是通过入栈和出栈来进行操作的。</p>
<h4 id="帧数据区">帧数据区</h4>
<p>在前面就描述过：栈是由栈帧组成，每当线程调用一个java方法时，JVM就会在该线程对应的栈中压入一个帧，而帧是由局部变量区、操作数栈和帧数据区组成。</p>
<ol>
<li>只有在调用一个方法时，才为当前栈分配一个帧，然后将该帧压入栈;</li>
<li>帧中存储了对应方法的局部数据，方法执行完，对应的帧则从栈中弹出，并把返回结果存储在调用方法的帧的操作数栈中。</li>
</ol>
<h1 id="堆">堆😵</h1>
<p>堆中分配的是对象，也就是new出来的东西。<br>
<img src="https://pic1.zhimg.com/80/v2-00dc88198eef4f42a3dd1e34ee5cd5f7_720w.jpg" alt="heap" loading="lazy"></p>
<h1 id="内存分配举个栗子">内存分配（举个栗子）</h1>
<pre><code>public void Method1()
{
    int i = 4;
    int y = 2;
    class1 cls1 = new class1();
}
</code></pre>
<p>内存分配是这样的：<br>
<img src="https://pic1.zhimg.com/80/1519fb641bdb1ee150fcfb621b0afdd8_720w.jpg" alt="img" loading="lazy"></p>
<h1 id="堆和栈的区别">堆和栈的区别🤗</h1>
<ul>
<li>功能不同<br>
栈内存用来存储局部变量和方法调用。<br>
而堆内存用来存储Java中的对象。无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中。</li>
<li>共享性不同<br>
  栈内存是线程私有的。<br>
  堆内存是所有线程共有的。</li>
<li>异常错误不同<br>
  如果栈内存或者堆内存不足都会抛出异常。<br>
  栈空间不足：java.lang.StackOverFlowError。<br>
  堆空间不足：java.lang.OutOfMemoryError。</li>
<li>空间大小<br>
  栈的空间大小远远小于堆的。</li>
<li>结构<br>
  stack是有结构的，每个区块按照一定次序存放，可以明确知道每个区块的大小；heap是没有结构的，数据可以任意存放。因此，stack的寻址速度要快于heap。</li>
<li>存放规则<br>
  数据存放的规则是：只要是局部的、占用空间确定的数据，一般都存放在stack里面，否则就放在heap里面。</li>
</ul>
<h3 id="参考文章">参考文章</h3>
<p><a href="https://www.zhihu.com/question/29833675/">https://www.zhihu.com/question/29833675</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Traefik V2基于Kubernetes的安装与使用]]></title>
        <id>https://hefeijoe.github.io/post/traefik-k8s-use/</id>
        <link href="https://hefeijoe.github.io/post/traefik-k8s-use/">
        </link>
        <updated>2020-05-20T07:05:06.000Z</updated>
        <content type="html"><![CDATA[<h1 id="核心概念">核心概念😀</h1>
<p>Traefik 是一个边缘路由器，是你整个平台的大门，拦截并路由每个传入的请求：它知道所有的逻辑和规则，这些规则确定哪些服务处理哪些请求；传统的反向代理需要一个配置文件，其中包含路由到你服务的所有可能路由，而 Traefik 会实时检测服务并自动更新路由规则，可以自动服务发现。<br>
<img src="https://docs.traefik.io/assets/img/traefik-architecture.png" alt="img" loading="lazy"><br>
首先，当启动 Traefik 时，需要定义 entrypoints（入口点），然后，根据连接到这些 entrypoints 的路由来分析传入的请求，来查看他们是否与一组规则相匹配，如果匹配，则路由可能会将请求通过一系列中间件转换过后再转发到你的服务上去。在了解 Traefik 之前有几个核心概念我们必须要了解：</p>
<ul>
<li><strong>Providers</strong> 用来自动发现平台上的服务，可以是编排工具、容器引擎或者 key-value 存储等，比如 Docker、Kubernetes、File。</li>
<li><strong>Entrypoints</strong> 监听传入的流量（端口等…），是网络入口点，它们定义了接收请求的端口（HTTP 或者 TCP）。</li>
<li><strong>Routers</strong> 分析请求（host, path, headers, SSL, …），负责将传入请求连接到可以处理这些请求的服务上去。</li>
<li><strong>Services</strong> 将请求转发给你的应用（load balancing, …），负责配置如何获取最终将处理传入请求的实际服务。</li>
<li><strong>Middlewares</strong> 中间件，用来修改请求或者根据请求来做出一些判断（authentication, rate limiting, headers, …），中间件被附件到路由上，是一种在请求发送到你的服务之前（或者在服务的响应发送到客户端之前）调整请求的一种方法。</li>
</ul>
<h1 id="部署">部署😄</h1>
<h2 id="kubernetes">Kubernetes</h2>
<p>由于 Traefik 2.X 版本和之前的 1.X 版本不兼容，我们这里选择功能更加强大的 2.X 版本进行部署，我们这里使用的镜像是 traefik:2.0.2。<br>
在 Traefik 中的配置可以使用两种不同的方式：</p>
<ul>
<li><strong>动态配置</strong>：完全动态的路由配置</li>
<li><strong>静态配置</strong>：启动配置<br>
静态配置中的元素（这些元素不会经常更改）连接到 providers 并定义 Treafik 将要监听的 entrypoints。<br>
在 Traefik 中有三种方式定义静态配置：在配置文件中、在命令行参数中、通过环境变量传递<br>
动态配置包含定义系统如何处理请求的所有配置内容，这些配置是可以改变的，而且是无缝热更新的，没有任何请求中断或连接损耗。<br>
在Kubernetes集群下，采用Deployment的方式部署traefik，并且打开kubernetes ingress，以及prometheus metrics。<br>
<em>注：默认安装在<strong>default</strong>下</em></li>
</ul>
<h3 id="crd与rbac">CRD与RBAC</h3>
<p>首先，定义CRD包括IngressRoute和Middleware。并且通过RBAC授权资源。<br>
参见：https://github.com/HefeiJoe/traefik-k8s/blob/master/traefik-crd.yaml<br>
<em>注：默认安装在<strong>default</strong>下</em></p>
<pre><code>kubectl apply -f https://github.com/HefeiJoe/traefik-k8s/blob/master/traefik-crd.yaml
</code></pre>
<h3 id="service">Service</h3>
<p>参见：https://github.com/HefeiJoe/traefik-k8s/blob/master/traefik-service.yaml</p>
<pre><code>kubectl apply -f https://github.com/HefeiJoe/traefik-k8s/blob/master/traefik-crd.yaml
</code></pre>
<p>部署完成traefik的EXTERNAL-IP为<a href="http://172.21.92.148:8080/dashboard/#/">172.21.92.146</a></p>
<h3 id="deployments">Deployments</h3>
<p>参见：https://github.com/HefeiJoe/traefik-k8s/blob/master/traefik-deployment.yaml</p>
<pre><code>kubectl apply -f https://github.com/HefeiJoe/traefik-k8s/blob/master/traefik-deployment.yaml
</code></pre>
<pre><code>apiVersion: v1
kind: ServiceAccount
metadata:
 name: traefik-ingress-controller
---
kind: Deployment
apiVersion: apps/v1
metadata:
 name: traefik
 labels:
  app: traefik
spec:
 replicas: 1
 selector:
  matchLabels:
   app: traefik
 template:
  metadata:
   labels:
​    app: traefik
  spec:
   serviceAccountName: traefik-ingress-controller
   containers:
​    - name: traefik
​     image: traefik:v2.0.2
​     args:
​      - --api.insecure
​      - --accesslog
​      - --entrypoints.web.Address=:8000
​      - --entrypoints.websecure.Address=:4443
​      - --providers.kubernetescrd
​      - --certificatesresolvers.default.acme.tlschallenge
​      - --certificatesresolvers.default.acme.email=foo@you.com
​      - --certificatesresolvers.default.acme.storage=acme.json
​      - --providers.kubernetesingress=true
​      - --providers.kubernetesingress.ingressclass=traefik
​      - --metrics.prometheus=true
​      - --entryPoints.metrics.address=:8082
​      - --metrics.prometheus.entryPoint=metrics
​      - --certificatesresolvers.default.acme.caserver=https://acme-staging-v02.api.letsencrypt.org/directory
​     ports:
​      - name: web
​       containerPort: 8000
​      - name: websecure
​       containerPort: 4443
​      - name: admin
​       containerPort: 8080
​      - name: prometheus
​       containerPort: 8082
</code></pre>
<h3 id="访问dashboard">访问DashBoard</h3>
<p>访问8080端口，<a href="http://172.21.92.148:8080/dashboard/#/">http://172.21.92.146:8080/dashboard/#/</a><br>
可以查看开启的端口、添加的HTTP服务、添加的TCP服务、启用的Middleware、启用的Features、已经授信的功能。<br>
<img src="https://uploader.shimo.im/f/9KL50flf9hg1UaL8.png!thumbnail" alt="img" loading="lazy"></p>
<h2 id="helm-chart">Helm Chart</h2>
<p>Helm Chart地址：https://github.com/containous/traefik-helm-chart<br>
helm install --namespace=default  ./traefik-helm-chart<br>
#使用</p>
<h3 id="部署whoami服务">部署whoami服务</h3>
<p>部署测试服务whoami<br>
参见：https://github.com/HefeiJoe/traefik-k8s/blob/master/whoami.yaml</p>
<h2 id="ingress">Ingress</h2>
<p>在traefik的Deployment中的arg下添加CLI<br>
<em>- --providers.kubernetesingress=true</em><br>
<em>- --providers.kubernetesingress.ingressclass=traefik</em><br>
1、创建Ingress</p>
<pre><code>kind: Ingress
apiVersion: extensions/v1beta1
metadata:
  namespace: default
 name: traefik-ingress
 annotations:
  *# use the shared ingress-nginx*
  kubernetes.io/ingress.class: traefik
</code></pre>
<p>2、验证<br>
访问服务curl -i 172.21.92.146:8000  -H &quot;Host:whoami.kong.test&quot;，接口响应200<br>
<img src="https://uploader.shimo.im/f/ffocrRF3UjkXYBEb.png!thumbnail" alt="img" loading="lazy"></p>
<h2 id="ingressroute">IngressRoute</h2>
<pre><code>apiVersion: traefik.containo.us/v1alpha1
kind: IngressRoute
metadata:
  name: simpleingressroute
  namespace: default
spec:
  entryPoints:
​    - web
  routes:
  - match: Host(`172.21.92.148`) &amp;&amp; PathPrefix(`/whoami`)
​    kind: Rule
​    services:
​    - name: whoami
​      port: 80
</code></pre>
<p>通过http://172.21.92.148:8000/whoami访问</p>
<h2 id="middlewares中间件">Middlewares（中间件）</h2>
<h3 id="overview概述">Overview（概述）</h3>
<h3 id=""><img src="https://uploader.shimo.im/f/S1b2FXezLpQkSqx3.png!thumbnail" alt="img" loading="lazy"></h3>
<p>将中间件添加到Route，在请求发送到服务之前(或在服务的响应发送到客户端之前)调整请求。<br>
Traefik中有许多不同的中间件，有些可以修改请求、头文件，有些负责重定向，有些添加身份验证，等等。<br>
<strong>给Route绑定Middleware</strong><br>
在ingressRoute中添加middlewares<br>
<em># As a Kubernetes Traefik IngressRoute</em></p>
<pre><code>apiVersion: traefik.containo.us/v1alpha1
kind: Middleware
metadata:
  name: stripprefix
spec:
  stripPrefix:
​    prefixes:
​      - /stripit
---
apiVersion: traefik.containo.us/v1alpha1
kind: IngressRoute
metadata:
  name: simpleingressroute
  namespace: default
spec:
  entryPoints:
​    - web
  routes:
  - match: Host(`172.21.92.148`) &amp;&amp; PathPrefix(`/whoami`)
​    kind: Rule
​    services:
​    - name: whoami
​      port: 80
​    middlewares:
- name: stripprefix
</code></pre>
<p>Available Middlewares<a href="https://docs.traefik.io/middlewares/overview/#available-middlewares">¶</a></p>
<table>
<thead>
<tr>
<th>Middleware</th>
<th>Purpose</th>
<th>Area</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://docs.traefik.io/middlewares/addprefix/">AddPrefix</a></td>
<td>Add a Path Prefix</td>
<td>Path Modifier</td>
</tr>
<tr>
<td><a href="https://docs.traefik.io/middlewares/basicauth/">BasicAuth</a></td>
<td>Basic auth mechanism</td>
<td>Security, Authentication</td>
</tr>
<tr>
<td><a href="https://docs.traefik.io/middlewares/buffering/">Buffering</a></td>
<td>Buffers the request/response</td>
<td>Request Lifecycle</td>
</tr>
<tr>
<td><a href="https://docs.traefik.io/middlewares/chain/">Chain</a></td>
<td>Combine multiple pieces of middleware</td>
<td>Middleware tool</td>
</tr>
<tr>
<td><a href="https://docs.traefik.io/middlewares/circuitbreaker/">CircuitBreaker</a></td>
<td>Stop calling unhealthy services</td>
<td>Request Lifecycle</td>
</tr>
<tr>
<td><a href="https://docs.traefik.io/middlewares/compress/">Compress</a></td>
<td>Compress the response</td>
<td>Content Modifier</td>
</tr>
<tr>
<td><a href="https://docs.traefik.io/middlewares/digestauth/">DigestAuth</a></td>
<td>Adds Digest Authentication</td>
<td>Security, Authentication</td>
</tr>
<tr>
<td><a href="https://docs.traefik.io/middlewares/errorpages/">Errors</a></td>
<td>Define custom error pages</td>
<td>Request Lifecycle</td>
</tr>
<tr>
<td><a href="https://docs.traefik.io/middlewares/forwardauth/">ForwardAuth</a></td>
<td>Authentication delegation</td>
<td>Security, Authentication</td>
</tr>
<tr>
<td><a href="https://docs.traefik.io/middlewares/headers/">Headers</a></td>
<td>Add / Update headers</td>
<td>Security</td>
</tr>
<tr>
<td><a href="https://docs.traefik.io/middlewares/ipwhitelist/">IPWhiteList</a></td>
<td>Limit the allowed client IPs</td>
<td>Security, Request lifecycle</td>
</tr>
<tr>
<td><a href="https://docs.traefik.io/middlewares/inflightreq/">InFlightReq</a></td>
<td>Limit the number of simultaneous connections</td>
<td>Security, Request lifecycle</td>
</tr>
<tr>
<td><a href="https://docs.traefik.io/middlewares/passtlsclientcert/">PassTLSClientCert</a></td>
<td>Adding Client Certificates in a Header</td>
<td>Security</td>
</tr>
<tr>
<td><a href="https://docs.traefik.io/middlewares/ratelimit/">RateLimit</a></td>
<td>Limit the call frequency</td>
<td>Security, Request lifecycle</td>
</tr>
<tr>
<td><a href="https://docs.traefik.io/middlewares/redirectscheme/">RedirectScheme</a></td>
<td>Redirect easily the client elsewhere</td>
<td>Request lifecycle</td>
</tr>
<tr>
<td><a href="https://docs.traefik.io/middlewares/redirectregex/">RedirectRegex</a></td>
<td>Redirect the client elsewhere</td>
<td>Request lifecycle</td>
</tr>
<tr>
<td><a href="https://docs.traefik.io/middlewares/replacepath/">ReplacePath</a></td>
<td>Change the path of the request</td>
<td>Path Modifier</td>
</tr>
<tr>
<td><a href="https://docs.traefik.io/middlewares/replacepathregex/">ReplacePathRegex</a></td>
<td>Change the path of the request</td>
<td>Path Modifier</td>
</tr>
<tr>
<td><a href="https://docs.traefik.io/middlewares/retry/">Retry</a></td>
<td>Automatically retry the request in case of errors</td>
<td>Request lifecycle</td>
</tr>
<tr>
<td><a href="https://docs.traefik.io/middlewares/stripprefix/">StripPrefix</a></td>
<td>Change the path of the request</td>
<td>Path Modifier</td>
</tr>
<tr>
<td><a href="https://docs.traefik.io/middlewares/stripprefixregex/">StripPrefixRegex</a></td>
<td>Change the path of the request</td>
<td>Path Modifier</td>
</tr>
</tbody>
</table>
<h3 id="addprefix添加前缀">AddPrefix（添加前缀）</h3>
<p><img src="https://uploader.shimo.im/f/1hy4I9o9piED68sO.png!thumbnail" alt="img" loading="lazy"><br>
<em># Prefixing with /foo</em></p>
<pre><code>apiVersion: traefik.containo.us/v1alpha1
kind: Middleware
metadata:
  name: add-foo
spec:
  addPrefix:
​    prefix: /foo
</code></pre>
<table>
<thead>
<tr>
<th>配置选项</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>prefix</td>
<td>prefix是添加在请求的URL路径之前的字符串。它应该包括前导斜杠(/)。参考<a href="https://docs.traefik.io/middlewares/addprefix/#prefix">¶</a></td>
</tr>
</tbody>
</table>
<h3 id="basicauth基本认证">BasicAuth（基本认证）</h3>
<p><img src="https://uploader.shimo.im/f/IRa08Sg9kIIT5DuU.png!thumbnail" alt="img" loading="lazy"><br>
<em># Declaring the user list</em></p>
<pre><code>apiVersion: traefik.containo.us/v1alpha1
kind: Middleware
metadata:
  name: test-auth
spec:
  basicAuth:
​    secret: secretName
</code></pre>
<table>
<thead>
<tr>
<th>配置选项</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>secret</td>
<td>绑定创建的secret。参考<a href="https://docs.traefik.io/middlewares/basicauth/#configuration-examples">¶</a></td>
</tr>
<tr>
<td>users</td>
<td>该users选项是一组授权用户。每个用户都将使用以下name:encoded-password格式声明。参考<a href="https://docs.traefik.io/middlewares/basicauth/#usersfile">¶</a></td>
</tr>
<tr>
<td>usersFile</td>
<td>该usersFile选项是包含中间件授权用户的外部文件的路径。参考<a href="https://docs.traefik.io/middlewares/basicauth/#realm">¶</a></td>
</tr>
<tr>
<td>realm</td>
<td>您可以使用realm选项来自定义身份验证领域。默认值为traefik。参考<a href="https://docs.traefik.io/middlewares/basicauth/#realm">¶</a></td>
</tr>
<tr>
<td>headerField</td>
<td>您可以使用该headerField选项定义标题字段以存储经过身份验证的用户。参考<a href="https://docs.traefik.io/middlewares/basicauth/#headerfield">¶</a></td>
</tr>
<tr>
<td>removeHeader</td>
<td>设置removeHeader选项以true在将请求转发到服务之前删除授权标头。（默认值为false。）参考<a href="https://docs.traefik.io/middlewares/basicauth/#removeheader">¶</a></td>
</tr>
</tbody>
</table>
<h3 id="circuitbreaker断路器">CircuitBreaker（断路器）</h3>
<p><img src="https://uploader.shimo.im/f/Jf3qvl3fwsgp5pDV.png!thumbnail" alt="img" loading="lazy"><br>
断路器可保护您的系统免于将请求堆叠到不正常的服务（导致级联故障）的麻烦。<br>
系统运行状况良好时，电路处于闭合状态（正常运行）。当系统运行不正常时，电路将断开，并且不再转发请求（而是由后备机制处理）。<br>
为了评估您的系统是否健康，断路器不断监视服务。<br>
<em># Latency Check</em></p>
<pre><code>apiVersion: traefik.containo.us/v1alpha1
kind: Middleware
metadata:
  name: latency-check
spec:
  circuitBreaker:
​    expression: LatencyAtQuantileMS(50.0) &gt; 100
</code></pre>
<table>
<thead>
<tr>
<th>配置选项</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>NetworkErrorRatio</td>
<td>如果您希望断路器以30％的网络错误率触发，则表达式为 NetworkErrorRatio() &gt; 0.30。参考<a href="https://docs.traefik.io/middlewares/addprefix/#prefix">¶</a></td>
</tr>
<tr>
<td>ResponseCodeRatio</td>
<td>您可以根据给定范围的状态码的比率来触发断路器。在ResponseCodeRatio接受四个参数，from，to，dividedByFrom，dividedByTo。例如，ResponseCodeRatio(500, 600, 0, 600) &gt; 0.25如果25％的请求返回5XX状态（在返回状态代码从0到5XX的请求中），则表达式将触发断路器。参考<a href="https://docs.traefik.io/middlewares/circuitbreaker/#responsecoderatio">¶</a></td>
</tr>
<tr>
<td>LatencyAtQuantileMS</td>
<td>当给定比例的请求变得太慢时，您可以触发断路器。例如，当中LatencyAtQuantileMS(50.0) &gt; 100值等待时间（分位数50）达到100MS时，该表达式将触发断路器。参考<a href="https://docs.traefik.io/middlewares/circuitbreaker/#latencyatquantilems">¶</a>您必须提供分位数的浮点数（后跟.0）</td>
</tr>
</tbody>
</table>
<h2 id="metrics">Metrics</h2>
<h3 id="prometheus">Prometheus</h3>
<p>在traefik的Deployment中的arg下添加CLI（如果采用HelmChart部署，在values.yaml的additionalArguments下添加以下CLI），并且修改Service暴露端口8082<br>
<em>- --metrics.prometheus=true</em><br>
<em>- --entryPoints.metrics.address=:8082</em><br>
<em>- --metrics.prometheus.entryPoint=metrics</em><br>
通过8082端口可以查看prometheus的metrics，<a href="http://172.21.92.148:8082/metrics">http://172.21.92.146:8082/metrics</a></p>
<h2 id="tracing">Tracing</h2>
<h3 id="zipkin">Zipkin</h3>
<p>1、部署Zipkin<br>
略<br>
2、在traefik的Deployment中的arg下添加CLI（如果采用HelmChart部署，在values.yaml的additionalArguments下添加以下CLI）<br>
<em>- --tracing.zipkin=true</em><br>
<em>- --tracing.zipkin.httpEndpoint=http://localhost:9411/api/v2/spans</em><br>
<em>- --tracing.zipkin.sampleRate=1.0</em><br>
访问zipkin的地址，http://localhost:9411/</p>
]]></content>
    </entry>
</feed>